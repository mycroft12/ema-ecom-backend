package com.mycroft.ema.ecom.domains.products.service.impl;

import com.mycroft.ema.ecom.common.error.NotFoundException;
import com.mycroft.ema.ecom.domains.products.dto.ProductCreateDto;
import com.mycroft.ema.ecom.domains.products.dto.ProductUpdateDto;
import com.mycroft.ema.ecom.domains.products.dto.ProductViewDto;
import com.mycroft.ema.ecom.domains.products.dto.ResponseDto;
import com.mycroft.ema.ecom.domains.products.service.ProductService;
import org.springframework.data.domain.*;
import org.springframework.stereotype.Service;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@Transactional(readOnly = true)
public class ProductServiceImpl implements ProductService {

  private final JdbcTemplate jdbc;
  private static final String TABLE = "product_config";

  public ProductServiceImpl(JdbcTemplate jdbc){
    this.jdbc=jdbc;
  }

  @Override
  public Page<ProductViewDto> search(String q, Pageable pageable) {
    if (!tableExists()) {
      return new PageImpl<>(Collections.emptyList(), pageable, 0);
    }
    long total = jdbc.queryForObject("select count(*) from " + TABLE, Long.class);
    int pageSize = pageable.getPageSize();
    int offset = (int) pageable.getOffset();

    // naive order by id; you can extend with dynamic sorting later
    List<Map<String, Object>> rows = jdbc.queryForList(
            "select * from " + TABLE + " order by id limit ? offset ?", pageSize, offset);

    List<ProductViewDto> content = new ArrayList<>();
    for (Map<String, Object> row : rows) {
      UUID id = row.get("id") == null ? null : UUID.fromString(row.get("id").toString());
      Map<String, Object> attrs = new LinkedHashMap<>(row);
      attrs.remove("id");
      content.add(new ProductViewDto(id, attrs));
    }
    return new PageImpl<>(content, pageable, total);
  }

  @Override
  @Transactional
  public ProductViewDto create(ProductCreateDto dto){
    Map<String, Object> attrs = dto.attributes() == null ? Collections.emptyMap() : dto.attributes();
    Set<String> valid = tableColumns();
    List<String> cols = new ArrayList<>();
    List<Object> vals = new ArrayList<>();
    for (Map.Entry<String,Object> e : attrs.entrySet()){
      String col = e.getKey();
      if ("id".equalsIgnoreCase(col)) continue; // id is mandatory but generated by DB
      if (valid.contains(col)){
        cols.add(col);
        vals.add(e.getValue());
      }
    }
    UUID id;
    if(cols.isEmpty()){
      id = jdbc.queryForObject("insert into " + TABLE + " default values returning id", UUID.class);
    }else{
      String placeholders = String.join(", ", Collections.nCopies(cols.size(), "?"));
      String columns = String.join(", ", cols);
      String sql = "insert into " + TABLE + " (" + columns + ") values (" + placeholders + ") returning id";
      id = jdbc.queryForObject(sql, vals.toArray(), UUID.class);
    }
    return get(id);
  }

  @Override
  @Transactional
  public ProductViewDto update(UUID id, ProductUpdateDto dto){
    Map<String, Object> attrs = dto.attributes() == null ? Collections.emptyMap() : dto.attributes();
    if(attrs.isEmpty()){
      return get(id);
    }
    Set<String> valid = tableColumns();
    List<String> sets = new ArrayList<>();
    List<Object> vals = new ArrayList<>();
    for (Map.Entry<String,Object> e : attrs.entrySet()){
      String col = e.getKey();
      if ("id".equalsIgnoreCase(col)) continue;
      if (valid.contains(col)){
        sets.add(col + " = ?");
        vals.add(e.getValue());
      }
    }
    if(!sets.isEmpty()){
      String sql = "update " + TABLE + " set " + String.join(", ", sets) + " where id = ?";
      vals.add(id);
      jdbc.update(sql, vals.toArray());
    }
    return get(id);
  }

  @Override
  @Transactional
  public void delete(UUID id){
    int updated = jdbc.update("delete from " + TABLE + " where id = ?", id);
    if (updated == 0) {
      throw new NotFoundException("Product not found");
    }
  }

  @Override
  public ProductViewDto get(UUID id){
    try {
      Map<String, Object> row = jdbc.queryForMap("select * from " + TABLE + " where id = ?", id);
      Map<String, Object> attrs = new LinkedHashMap<>(row);
      attrs.remove("id");
      return new ProductViewDto(id, attrs);
    } catch (EmptyResultDataAccessException ex){
      throw new NotFoundException("Product not found");
    }
  }

  private boolean tableExists() {
    Integer count = jdbc.queryForObject("""
      select count(*) from information_schema.tables 
      where table_schema = current_schema() and table_name = ?
      """, Integer.class, TABLE);
    return count != null && count > 0;
  }

  @Override
  public List<ResponseDto.ColumnDto> listColumns() {
    if (!tableExists()) return List.of(); // unconfigured state

    List<Map<String,Object>> rows = jdbc.queryForList("""
      select column_name, data_type, ordinal_position 
      from information_schema.columns
      where table_schema = current_schema() and table_name = ?
      order by ordinal_position
      """, TABLE);

    List<ResponseDto.ColumnDto> cols = new ArrayList<>();
    for (Map<String,Object> r : rows) {
      String name = String.valueOf(r.get("column_name"));
      if ("id".equalsIgnoreCase(name)) continue; // we keep id as dataKey but not visible

      String dataType = String.valueOf(r.get("data_type"));
      int order = Integer.parseInt(String.valueOf(r.get("ordinal_position"))) - 1;

      ResponseDto.ColumnType type = mapSqlTypeToColumnType(name, dataType);
      String displayName = prettify(name);

      cols.add(new ResponseDto.ColumnDto(name, displayName, type, false, order));
    }
    return cols;
  }

  private ResponseDto.ColumnType mapSqlTypeToColumnType(String name, String dataType) {
    // Name hints first (let you render the “example” widgets on FE)
    String n = name.toLowerCase();
    if (n.contains("image") || n.endsWith("_url")) return ResponseDto.ColumnType.MINIO_IMAGE;
    if (n.equals("status")) return ResponseDto.ColumnType.TEXT;
    if (n.equals("activity")) return ResponseDto.ColumnType.INTEGER;
    if (n.equals("representative") || n.equals("country")) return ResponseDto.ColumnType.TEXT;

    // SQL type mapping (PostgreSQL-ish; adapt if you use another DB)
    String dt = dataType.toLowerCase();
    if (dt.contains("bool")) return ResponseDto.ColumnType.BOOLEAN;
    if (dt.contains("int")) return ResponseDto.ColumnType.INTEGER;
    if (dt.contains("numeric") || dt.contains("decimal") || dt.contains("double") || dt.contains("real")) return ResponseDto.ColumnType.DECIMAL;
    if (dt.contains("date") || dt.contains("timestamp")) return ResponseDto.ColumnType.DATE;

    return ResponseDto.ColumnType.TEXT;
  }

  private String prettify(String name) {
    return Arrays.stream(name.replace('_', ' ').split(" "))
            .filter(s -> !s.isBlank())
            .map(s -> Character.toUpperCase(s.charAt(0)) + s.substring(1))
            .collect(Collectors.joining(" "));
  }



  private Set<String> tableColumns(){
    return new HashSet<>(jdbc.queryForList(
        "select column_name from information_schema.columns where table_name = ?",
        String.class, TABLE));
  }
}
