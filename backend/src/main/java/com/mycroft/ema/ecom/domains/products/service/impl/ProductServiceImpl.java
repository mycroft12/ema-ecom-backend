package com.mycroft.ema.ecom.domains.products.service.impl;

import com.mycroft.ema.ecom.common.error.NotFoundException;
import com.mycroft.ema.ecom.domains.products.dto.ProductCreateDto;
import com.mycroft.ema.ecom.domains.products.dto.ProductUpdateDto;
import com.mycroft.ema.ecom.domains.products.dto.ProductViewDto;
import com.mycroft.ema.ecom.domains.products.dto.ResponseDto;
import com.mycroft.ema.ecom.domains.products.service.ProductService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.*;
import org.springframework.stereotype.Service;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Locale;
import java.util.stream.Collectors;

@Service
@Transactional(readOnly = true)
public class ProductServiceImpl implements ProductService {

  private final JdbcTemplate jdbc;
  private static final String TABLE = "product_config";
  private final String quotedTable;
  private static final Logger log = LoggerFactory.getLogger(ProductServiceImpl.class);

  public ProductServiceImpl(JdbcTemplate jdbc){
    this.jdbc=jdbc;
    this.quotedTable = TABLE;
  }

  @Override
  public Page<ProductViewDto> search(String q, Pageable pageable) {
    if (!tableExists()) {
      return new PageImpl<>(Collections.emptyList(), pageable, 0);
    }
    long total = jdbc.queryForObject("select count(*) from " + quotedTable, Long.class);
    int pageSize = pageable.getPageSize();
    int offset = (int) pageable.getOffset();

    // naive order by id; you can extend with dynamic sorting later
    List<Map<String, Object>> rows = jdbc.queryForList(
            "select * from " + quotedTable + " order by id limit ? offset ?", pageSize, offset);

    List<ProductViewDto> content = new ArrayList<>();
    for (Map<String, Object> row : rows) {
      UUID id = row.get("id") == null ? null : UUID.fromString(row.get("id").toString());
      Map<String, Object> attrs = new LinkedHashMap<>(row);
      attrs.remove("id");
      content.add(new ProductViewDto(id, attrs));
    }
    return new PageImpl<>(content, pageable, total);
  }

  @Override
  @Transactional
  public ProductViewDto create(ProductCreateDto dto){
    Map<String, Object> attrs = dto.attributes() == null ? Collections.emptyMap() : dto.attributes();
    Map<String, ColumnMeta> columnLookup = columnMetadata();
    List<String> cols = new ArrayList<>();
    List<Object> vals = new ArrayList<>();
    for (Map.Entry<String,Object> e : attrs.entrySet()){
      String col = Optional.ofNullable(e.getKey()).orElse("");
      ColumnMeta meta = columnLookup.get(col.toLowerCase(Locale.ROOT));
      if (meta == null) continue;
      String actual = meta.name();
      if ("id".equalsIgnoreCase(col)) continue; // id is mandatory but generated by DB
      if ("id".equalsIgnoreCase(actual)) continue;
      cols.add(actual);
      vals.add(convertValue(meta, e.getValue()));
    }
    UUID id;
    if(cols.isEmpty()){
      id = jdbc.queryForObject("insert into " + quotedTable + " default values returning id", UUID.class);
    }else{
      String placeholders = String.join(", ", Collections.nCopies(cols.size(), "?"));
      String columns = String.join(", ", cols);
      String sql = "insert into " + quotedTable + " (" + columns + ") values (" + placeholders + ") returning id";
      if (log.isDebugEnabled()) {
        log.debug("Product insert SQL={} columns={} values={}", sql, cols, vals);
      }
      id = jdbc.queryForObject(sql, vals.toArray(), UUID.class);
    }
    return get(id);
  }

  @Override
  @Transactional
  public ProductViewDto update(UUID id, ProductUpdateDto dto){
    Map<String, Object> attrs = dto.attributes() == null ? Collections.emptyMap() : dto.attributes();
    if(attrs.isEmpty()){
      return get(id);
    }
    Map<String, ColumnMeta> columnLookup = columnMetadata();
    List<String> sets = new ArrayList<>();
    List<Object> vals = new ArrayList<>();
    for (Map.Entry<String,Object> e : attrs.entrySet()){
      String col = Optional.ofNullable(e.getKey()).orElse("");
      ColumnMeta meta = columnLookup.get(col.toLowerCase(Locale.ROOT));
      if (meta == null) continue;
      String actual = meta.name();
      if ("id".equalsIgnoreCase(actual)) continue;
      sets.add(actual + " = ?");
      vals.add(convertValue(meta, e.getValue()));
    }
    if(!sets.isEmpty()){
      String sql = "update " + quotedTable + " set " + String.join(", ", sets) + " where id = ?";
      vals.add(id);
      if (log.isDebugEnabled()) {
        log.debug("Product update SQL={} sets={} values={} knownColumns={}", sql, sets, vals,
            columnLookup.values().stream().map(ColumnMeta::name).toList());
      }
      jdbc.update(sql, vals.toArray());
    } else if (log.isDebugEnabled()) {
      log.debug("No matching columns to update for product {}. IncomingKeys={} knownColumns={}", id, attrs.keySet(),
          columnLookup.values().stream().map(ColumnMeta::name).toList());
    }
    return get(id);
  }

  @Override
  @Transactional
  public void delete(UUID id){
    int updated = jdbc.update("delete from " + quotedTable + " where id = ?", id);
    if (updated == 0) {
      throw new NotFoundException("Product not found");
    }
  }

  @Override
  public ProductViewDto get(UUID id){
    try {
      Map<String, Object> row = jdbc.queryForMap("select * from " + quotedTable + " where id = ?", id);
      Map<String, Object> attrs = new LinkedHashMap<>(row);
      attrs.remove("id");
      return new ProductViewDto(id, attrs);
    } catch (EmptyResultDataAccessException ex){
      throw new NotFoundException("Product not found");
    }
  }

  private boolean tableExists() {
    Integer count = jdbc.queryForObject("""
      select count(*) from information_schema.tables 
      where table_schema = current_schema() and table_name = ?
      """, Integer.class, TABLE);
    return count != null && count > 0;
  }

  @Override
  public List<ResponseDto.ColumnDto> listColumns() {
    if (!tableExists()) return List.of(); // unconfigured state

    List<Map<String,Object>> rows = jdbc.queryForList("""
      select column_name, data_type, ordinal_position 
      from information_schema.columns
      where table_schema = current_schema() and table_name = ?
      order by ordinal_position
      """, TABLE);

    List<ResponseDto.ColumnDto> cols = new ArrayList<>();
    for (Map<String,Object> r : rows) {
      String name = String.valueOf(r.get("column_name"));
      if ("id".equalsIgnoreCase(name)) continue; // we keep id as dataKey but not visible

      String dataType = String.valueOf(r.get("data_type"));
      int order = Integer.parseInt(String.valueOf(r.get("ordinal_position"))) - 1;

      ResponseDto.ColumnType type = mapSqlTypeToColumnType(name, dataType);
      String displayName = prettify(name);

      cols.add(new ResponseDto.ColumnDto(name, displayName, type, false, order));
    }
    return cols;
  }

  private ResponseDto.ColumnType mapSqlTypeToColumnType(String name, String dataType) {
    // Name hints first (let you render the “example” widgets on FE)
    String n = name.toLowerCase();
    if (n.contains("image") || n.endsWith("_url")) return ResponseDto.ColumnType.MINIO_IMAGE;
    if (n.equals("status")) return ResponseDto.ColumnType.TEXT;
    if (n.equals("activity")) return ResponseDto.ColumnType.INTEGER;
    if (n.equals("representative") || n.equals("country")) return ResponseDto.ColumnType.TEXT;

    // SQL type mapping (PostgreSQL-ish; adapt if you use another DB)
    String dt = dataType.toLowerCase();
    if (dt.contains("bool")) return ResponseDto.ColumnType.BOOLEAN;
    if (dt.contains("int")) return ResponseDto.ColumnType.INTEGER;
    if (dt.contains("numeric") || dt.contains("decimal") || dt.contains("double") || dt.contains("real")) return ResponseDto.ColumnType.DECIMAL;
    if (dt.contains("date") || dt.contains("timestamp")) return ResponseDto.ColumnType.DATE;

    return ResponseDto.ColumnType.TEXT;
  }

  private String prettify(String name) {
    return Arrays.stream(name.replace('_', ' ').split(" "))
            .filter(s -> !s.isBlank())
            .map(s -> Character.toUpperCase(s.charAt(0)) + s.substring(1))
            .collect(Collectors.joining(" "));
  }



  private Map<String, ColumnMeta> columnMetadata() {
    Map<String, ColumnMeta> map = new HashMap<>();
    jdbc.query(
        """
          select column_name, data_type
          from information_schema.columns
          where table_schema = current_schema()
            and table_name = ?
        """,
        rs -> {
          String name = rs.getString("column_name");
          String type = rs.getString("data_type");
          if (name != null) {
            map.put(name.toLowerCase(Locale.ROOT), new ColumnMeta(name, type));
          }
        },
        TABLE);
    return map;
  }

  private Object convertValue(ColumnMeta meta, Object value) {
    if (value == null) {
      return null;
    }
    String dataType = meta.dataType() == null ? "" : meta.dataType().toLowerCase(Locale.ROOT);

    try {
      if (dataType.contains("timestamp")) {
        if (value instanceof Timestamp ts) return ts;
        if (value instanceof Instant instant) return Timestamp.from(instant);
        if (value instanceof LocalDateTime ldt) return Timestamp.valueOf(ldt);
        if (value instanceof CharSequence cs) {
          String text = cs.toString().trim();
          if (text.isEmpty()) return null;
          try {
            return Timestamp.from(Instant.parse(text));
          } catch (Exception ignored) {}
          try {
            return Timestamp.valueOf(LocalDateTime.parse(text, DateTimeFormatter.ISO_LOCAL_DATE_TIME));
          } catch (Exception ignored) {}
          String normalized = text.replace('T', ' ').replace("Z", "");
          return Timestamp.valueOf(normalized);
        }
      }

      if (dataType.contains("numeric") || dataType.contains("decimal")) {
        if (value instanceof BigDecimal bd) return bd;
        if (value instanceof Number number) {
          return BigDecimal.valueOf(number.doubleValue());
        }
        if (value instanceof CharSequence cs) {
          String text = cs.toString().trim();
          if (text.isEmpty()) return null;
          return new BigDecimal(text);
        }
      }

      if (dataType.contains("bigint")) {
        if (value instanceof Number number) {
          return number.longValue();
        }
        if (value instanceof CharSequence cs) {
          String text = cs.toString().trim();
          if (text.isEmpty()) return null;
          return Long.parseLong(text);
        }
      }
    } catch (Exception ex) {
      if (log.isDebugEnabled()) {
        log.debug("Failed to coerce value '{}' for column '{}' ({}). Using raw value.", value, meta.name(), dataType, ex);
      }
    }

    return value;
  }

  private record ColumnMeta(String name, String dataType) {}

}
