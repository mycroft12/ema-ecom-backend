package com.mycroft.ema.ecom.domains.products.service.impl;

import com.mycroft.ema.ecom.common.error.NotFoundException;
import com.mycroft.ema.ecom.domains.products.dto.ProductCreateDto;
import com.mycroft.ema.ecom.domains.products.dto.ProductUpdateDto;
import com.mycroft.ema.ecom.domains.products.dto.ProductViewDto;
import com.mycroft.ema.ecom.domains.products.service.ProductService;
import org.springframework.data.domain.*;
import org.springframework.stereotype.Service;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.dao.EmptyResultDataAccessException;

import java.util.*;

@Service
public class ProductServiceImpl implements ProductService {

  private final JdbcTemplate jdbc;
  private static final String TABLE = "product_config";

  public ProductServiceImpl(JdbcTemplate jdbc){
    this.jdbc=jdbc;
  }

  @Override
  public Page<ProductViewDto> search(String q, Pageable pageable){
    // If the dynamic table doesn't exist yet (unconfigured state), return empty page gracefully
    if (!tableExists()) {
      return new PageImpl<>(Collections.emptyList(), pageable, 0);
    }
    // Server-side paging using JDBC against dynamic table
    long total = jdbc.queryForObject("select count(*) from " + TABLE, Long.class);
    int pageSize = pageable.getPageSize();
    int offset = (int) pageable.getOffset();
    // For simplicity, ignore sorting and q for now; could be enhanced to dynamic SQL
    List<Map<String, Object>> rows = jdbc.queryForList(
        "select * from " + TABLE + " order by id limit ? offset ?", pageSize, offset);
    List<ProductViewDto> content = new ArrayList<>();
    for(Map<String, Object> row : rows){
      UUID id = row.get("id") == null ? null : UUID.fromString(row.get("id").toString());
      Map<String, Object> attrs = new LinkedHashMap<>(row);
      attrs.remove("id");
      content.add(new ProductViewDto(id, attrs));
    }
    return new PageImpl<>(content, pageable, total);
  }
  @Override
  public ProductViewDto create(ProductCreateDto dto){
    Map<String, Object> attrs = dto.attributes() == null ? Collections.emptyMap() : dto.attributes();
    Set<String> valid = tableColumns();
    List<String> cols = new ArrayList<>();
    List<Object> vals = new ArrayList<>();
    for (Map.Entry<String,Object> e : attrs.entrySet()){
      String col = e.getKey();
      if ("id".equalsIgnoreCase(col)) continue; // id is mandatory but generated by DB
      if (valid.contains(col)){
        cols.add(col);
        vals.add(e.getValue());
      }
    }
    UUID id;
    if(cols.isEmpty()){
      id = jdbc.queryForObject("insert into " + TABLE + " default values returning id", UUID.class);
    }else{
      String placeholders = String.join(", ", Collections.nCopies(cols.size(), "?"));
      String columns = String.join(", ", cols);
      String sql = "insert into " + TABLE + " (" + columns + ") values (" + placeholders + ") returning id";
      id = jdbc.queryForObject(sql, vals.toArray(), UUID.class);
    }
    return get(id);
  }

  @Override
  public ProductViewDto update(UUID id, ProductUpdateDto dto){
    Map<String, Object> attrs = dto.attributes() == null ? Collections.emptyMap() : dto.attributes();
    if(attrs.isEmpty()){
      return get(id);
    }
    Set<String> valid = tableColumns();
    List<String> sets = new ArrayList<>();
    List<Object> vals = new ArrayList<>();
    for (Map.Entry<String,Object> e : attrs.entrySet()){
      String col = e.getKey();
      if ("id".equalsIgnoreCase(col)) continue;
      if (valid.contains(col)){
        sets.add(col + " = ?");
        vals.add(e.getValue());
      }
    }
    if(!sets.isEmpty()){
      String sql = "update " + TABLE + " set " + String.join(", ", sets) + " where id = ?";
      vals.add(id);
      jdbc.update(sql, vals.toArray());
    }
    return get(id);
  }

  @Override
  public void delete(UUID id){
    jdbc.update("delete from " + TABLE + " where id = ?", id);
  }

  @Override
  public ProductViewDto get(UUID id){
    try {
      Map<String, Object> row = jdbc.queryForMap("select * from " + TABLE + " where id = ?", id);
      Map<String, Object> attrs = new LinkedHashMap<>(row);
      attrs.remove("id");
      return new ProductViewDto(id, attrs);
    } catch (EmptyResultDataAccessException ex){
      throw new NotFoundException("Product not found");
    }
  }

  private boolean tableExists(){
    Boolean exists = jdbc.queryForObject(
        "select exists (select 1 from information_schema.tables where table_schema = current_schema() and table_name = ?)",
        Boolean.class, TABLE);
    return Boolean.TRUE.equals(exists);
  }

  private Set<String> tableColumns(){
    return new HashSet<>(jdbc.queryForList(
        "select column_name from information_schema.columns where table_name = ?",
        String.class, TABLE));
  }
}
