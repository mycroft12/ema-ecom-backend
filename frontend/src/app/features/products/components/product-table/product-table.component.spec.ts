import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ProductTableComponent } from './product-table.component';
import { ProductDataService, MinioUploadResponse } from '../../services/product-data.service';
import { ProductSchemaService } from '../../services/product-schema.service';
import { AuthService } from '../../../../core/auth.service';
import { TranslateService } from '@ngx-translate/core';
import { ProductBadgeService, ProductUpsertEvent } from '../../services/product-badge.service';
import { ColumnDefinition, ColumnType, MinioImageValue } from '../../models/product-schema.model';
import { EventEmitter, Signal, signal } from '@angular/core';
import { of } from 'rxjs';
import { NO_ERRORS_SCHEMA } from '@angular/core';

class ProductDataServiceStub {
  private data: any[] = [];

  loadProducts(): any {
    return of({ content: [], totalElements: 0, totalPages: 0, page: 0, size: 0 });
  }

  products(): any[] {
    return this.data;
  }

  uploadProductImage(): any {
    return of({ key: 'k', url: 'https://example.com/img.jpg' } as MinioUploadResponse);
  }

  updateProduct(): any {
    return of({});
  }
}

class ProductSchemaServiceStub {
  translationNamespace = 'products';
  entityTypeName = 'product';

  private readonly columns: ColumnDefinition[] = [
    {
      name: 'image_url',
      displayName: 'Image',
      labelKey: 'image',
      type: ColumnType.MINIO_IMAGE,
      required: false,
      unique: false,
      hidden: false,
      primaryKey: false,
      autoGenerated: false,
      displayOrder: 0,
      mediaConstraints: { maxImages: 1 }
    }
  ];

  visibleColumns(): ColumnDefinition[] {
    return this.columns;
  }

  schema(): any {
    return null;
  }
}

class AuthServiceStub {
  permissions(): string[] {
    return ['product:update'];
  }

  isAuthenticated(): boolean {
    return true;
  }
}

class TranslateServiceStub {
  onLangChange = new EventEmitter();

  instant(key: string): string {
    return key;
  }
}

class ProductBadgeServiceStub {
  private readonly eventSignal: Signal<ProductUpsertEvent | null> = signal<ProductUpsertEvent | null>(null);

  upsertEvents(): Signal<ProductUpsertEvent | null> {
    return this.eventSignal;
  }
}

describe('ProductTableComponent (MINIO image rendering)', () => {
  let fixture: ComponentFixture<ProductTableComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ProductTableComponent],
      providers: [
        { provide: ProductDataService, useClass: ProductDataServiceStub },
        { provide: ProductSchemaService, useClass: ProductSchemaServiceStub },
        { provide: AuthService, useClass: AuthServiceStub },
        { provide: TranslateService, useClass: TranslateServiceStub },
        { provide: ProductBadgeService, useClass: ProductBadgeServiceStub }
      ],
      schemas: [NO_ERRORS_SCHEMA]
    }).compileComponents();

    fixture = TestBed.createComponent(ProductTableComponent);
    fixture.detectChanges();
  });

  it('renders an upload action for MINIO image columns', () => {
    fixture.detectChanges();
    const button: HTMLButtonElement | null = fixture.nativeElement.querySelector('button[aria-label="products.uploadImage"]');
    expect(button).withContext('Upload button should exist for MINIO image columns').not.toBeNull();
  });

  it('normalizes MINIO payloads before save', () => {
    const component = fixture.componentInstance;
    const column = TestBed.inject(ProductSchemaService).visibleColumns()[0];
    const payload: MinioImageValue = {
      type: 'MINIO_IMAGE',
      items: [{ key: 'a', url: 'https://example.com/a.jpg' }]
    };

    const normalized = (component as any).normalizeMinioPayloadForSave(payload, column);
    expect(normalized?.items?.length).toBe(1);
    expect(normalized?.items?.[0]?.url).toBe('https://example.com/a.jpg');
  });
});
